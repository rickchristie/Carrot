<h1>Quick Introduction to Carrot</h1>
<p>The very first thing you need to know is that Carrot is an experimental framework built by someone who is in junior level programming, so don't expect too much. Another thing is that I am developing Carrot for my personal use (and as a learning project), so some of the design decisions might not suit you. Since Carrot is still in its early stages, I would advice against using it in production unless you really wanted to dig in to Carrot and understand all the core classes.</p>
<h2>Globals and statics</h2>
<blockquote>
<p>&ldquo;The keyword static now enables us to use methods and properties (state) per-class and not on a per-object basis. This basically leaves us with class oriented programming. This seems to make a lot of things simpler, at a first glance, but will almost certainly hurt you in the long term.&rdquo; - <cite><a href="http://kore-nordmann.de/blog/0103_static_considered_harmful.html">Static Considered Harmful, Kore Nordmann</a></cite></p>
</blockquote>
<p>Carrot doesn't use globals and statics. This is a design decision already made and it is not going to change. In fact, the entire code in Carrot is written so that when I use it, I never have to resort to global variables or static methods. Why is globals and statics such a bad thing that I wanted to avoid it? Here is a short list, gathered from many sources:</p>
<ul>
    <li><strong>Makes your code hard to understand.</strong> Your code will be easier to understand if it were to use variables with limited scope. Global variables can be read or modified by any part of the program, making it difficult to remember or reason about every possible use. See also: <em>encourages tight coupling</em>. <a href="#source-c2"><sup>[1]</sup></a></li>
    <li><strong>Masks dependencies.</strong> You never know real dependencies of a class from its API, you have to read the source code, line-by-line to figure out the dependencies. Using statics and globals turns your code into a pathological liars. You think <code>Foo</code> doesn't need class/variable <code>Bar</code> when in fact accesses <code>Bar</code> via a global keyword or a static method/variable. <a href="#source-c2"><sup>[1]</sup></a> <a href="#source-misko-singleton-liars"><sup>[2]</sup></a></li>
    <li><strong>Breaks encapsulation.</strong> In OOP, data and behavior should be encapsulated in one object. If the object somehow reaches out of its boundaries to the global state, you are breaking encapsulation. <a href="#source-so-gordon-globals"><sup>[3]</sup></a></li>
    <li><strong>Encourages tight coupling.</strong> In an ideal world, an object should only be able to interact only with other objects which are directly passed into it, either through a constructor or method call. With the existence of globals and statics, object <code>Foo</code> can get a hold of globally accessible <code>Bar</code> even though it is not supposed to have access to it. This couples <code>Foo</code> with the global state, and if there is a bug related to <code>Bar</code>, you'll have to hunt the entire source code because you don't know which part of the code actually uses it. <a href="#source-misko-globals-flaw"><sup>[4]</sup></a></li>
    <li><strong>Spooky action at a distance.</strong> You run a method that is supposed to be isolated, and an action occurs in distant locations of the systems which we did not tell the object about. Whenever you use globals or statics, you are creating secret communications channel that are not exposed in the API. When it happens, <a href="http://en.wikipedia.org/wiki/Action_at_a_distance_%28computer_science%29">spooky action at a distance</a> forces developers to read every line of code to understand potential interactions. See also: <em>makes your code hard to understand</em>. <a href="#source-misko-globals-flaw"><sup>[4]</sup></a></li>
    <li><strong>Creates static dependencies.</strong> When you're using static methods, you are creating a static dependency that you might not be able to replace by any means other than editing the source. Let's say <code>Foo</code> has a static dependency to <code>Bar::baz()</code>, and you need to change the implementation of <code>Baz</code>. You won't be able to do that without editing <code>Foo</code>'s source. In OOP with dependency injection, you should be able to do this just with injecting another class, using <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov's subtitution principle</a>. <a href="#source-kore-static-harmful"><sup>[5]</sup></a></li>
    <li><strong>Makes unit testing very difficult.</strong> Unit testing needs seams, where we prevent the execution of normal code and achieve isolation of the class being tested. Without isolation, there is no unit test. These seams work through polymorphism and dependency injection, we override/implement an interface and inject it to the class. With statics, we cannot do this. Also, usage of a global state means that every test must start in an expected state, or the test will fail. <a href="#source-misko-globals-flaw"><sup>[4]</sup></a> <a href="#source-misko-statics-testability"><sup>[6]</sup></a></li>
</ul>
<p>I'm sure there are more reasons why globals and statics should be avoided, but let's just leave it at that. There are lots of positions regarding globals and statics. There are camps that loathes globals but seemed to be okay with statics since it doesn't pollute the global namespace, but it is such a slippery slope that I decided not to use it altogether. You can think of Carrot as an ongoing experiment on whether we can write a fully functional PHP framework without the usage of globals and statics.</p>
<p>Ruling out globals and statics means also ruling out <a href="http://martinfowler.com/eaaCatalog/registry.html">Registry</a> and <a href="http://en.wikipedia.org/wiki/Singleton_pattern">Singleton pattern</a>. This perplexes me for a while, since Carrot as a framework must provide a way for user's classes to access other instantiated objects. I need a way to wire the dependencies without resorting to globals or inheritance. I found the solution in <a href="http://martinfowler.com/articles/injection.html">dependency injection container</a> - hence why the usage of dependency injection container is mandatory in Carrot. More on this later.</p>
<h3>Sources</h3>
<ol>
    <li id="source-c2"><cite><a href="http://c2.com/cgi/wiki?GlobalVariablesAreBad">Global Variables are Bad</a>.</cite></li>
    <li id="source-misko-singleton-liars"><cite><a href="http://misko.hevery.com/2008/08/17/singletons-are-pathological-liars/">Singletons are Pathological Liars</a>, Misko Hevery.</cite></li>
    <li id="source-so-gordon-globals"><cite><a href="http://stackoverflow.com/questions/5166087/php-global-in-functions/5166527#5166527">Globals are Evil</a>, Gordon Oheim.</cite></li>
    <li id="source-misko-globals-flaw"><cite><a href="http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/">Flaw: Brittle Global State and Singletons</a>, Misko Hevery.</cite></li>
    <li id="source-kore-static-harmful"><cite><a href="http://kore-nordmann.de/blog/0103_static_considered_harmful.html">Static Considered Harmful</a>, Kore Nordmann.</cite></li>
    <li id="source-misko-statics-testability"><cite><a href="http://googletesting.blogspot.com/2008/12/static-methods-are-death-to-testability.html">Static Methods are Death to Testability</a>, Misko Hevery.</cite></li>
</ol>
<h2>Routine class</h2>
<blockquote><p>rou&bull;tine, noun. a sequence of actions regularly followed; a fixed program. - <cite>New Oxford American Dictionary</cite></p></blockquote>
<p>When you write a web application, you want a routine to be run when it is requested. This routine can be located in a function, an object method, or an anonymous function. For example, <a href="http://silex-project.org/">Silex</a> uses anonymous functions to store these routines, <a href="http://www.limonade-php.net/">Limonade</a> uses regular functions, and <a href="http://kohanaframework.org/">Kohana</a> uses a controller class (object method). Carrot is an object oriented framework, so your routine must be written inside an object method. We will call the methods that contain these routines: <em>routine methods</em>. The classes/objects that contains these routine methods are henceforth called <em>routine classes/objects</em>.</p>
<p>Unlike other frameworks, your routine class does not need to be your controller. It can be your view, or any random types of class. Carrot is not an MVC framework and doesn't pretend to be one. You can implement MVC in top of Carrot, of course, but it is not the only way you can use Carrot. The only responsibility that your routine method has to the framework is to return an instance of an implementation of <code>ResponseInterface</code>, how exactly you do that is up to you.</p>
<h2>Dependency injection and the container</h2>
<blockquote><p>&ldquo;So the core problem is how do we assemble these plugins into an application? This is one of the main problems that this new breed of lightweight containers face, and universally they all do it using Inversion of Control.&rdquo; - <cite><a href="http://martinfowler.com/articles/injection.html">Inversion of Control Containers and Dependency Injection Pattern, Martin Fowler</a></cite></p></blockquote>
<p>You can freely organize routine methods into routine classes, and you can have as many routine classes as you like. However, your routine class can't work on its own. It needs other objects - it has dependencies. So how do we wire the dependencies of your routine class? Wiring dependencies are easy in PHP, where you can create object properties on the fly - but it's not what I wanted. I wanted the dependencies wired using constructor injection, and I don't want to require routine classes to extend a base class. Both requirements will result in:</p>
<ul>
    <li>The routine class having no dependency whatsoever to the framework, it can be a plain old PHP object. It doesn't know that it is being attached to Carrot. This should make it easier </li>
    <li>Well designed API, at least </li>
</ul>
<p>The most frequent ways to solve this problem is using a configuration file. This almost certainly requires you to extend </p>
<h2>Routing</h2>
<p>So you have your routine class and you have wired its dependencies using provider classes. How do you determine which routine method is run when a request arrives? This is the responsibility of the <code>Router</code>.</p>
<h2>Class autoloading and PSR-0 compliance</h2>
<p>asdf</p>
<h2>Directory structure</h2>
<p>asdf</p>
<h2>Exception handling</h2>
<p>Exception handling</p>