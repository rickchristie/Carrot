TODO: Finish Carrot\Helper\Template, make the dependency as loose as possible
TODO: Finish Carrot\Driver\MySQLDatabase, make the dependency as loose as possible (consider adding Carrot\Drivers\Interfaces\DatabaseInterface)
TODO: Refactor Carrot\Session package, add flash variable support, different storage mechanisms, consider using SessionStorageInterface, take hints from Symfony!
TODO: Finish Carrot\Helper\Config
TODO: Finish Carrot\Helper\URL
TODO: Finish Validation, take hints from Zend's validation process
TODO: Start making unit tests
TODO: Add bootstrap class capability, create BootstrapInterface to make it easier, probably add TearDownInterface too, e.g. code to run after Response is set?
TODO: Make StatementWrapper has a result object that implements Iterator?
TODO: Make the default app (welcome screen) a sample app, don't bake it to the system?
TODO: Fix exception handling, make it default to exception handling? Use Http404Exception?
TODO: Make it so that the $dic exists solely at index.php, remove FrontController's dependency to $dic, refactor.

DOCUMENTATION
-------------

TODO: Fix comments on all classes, add @throws to denote exception thrown, and why it is thrown.
TODO: Fix comments on all classes, add @see to denote protected class caller
TODO: Fix comments on all classes to use full namespaces, for every @param and @return, use full namespace for object type, so @param \MySQLi_STMT $stmt comments..
TODO: Update the Welcome page
TODO: Fix comments on Database library (you changed namespaces, wait for it to stabilize)

NOTES
-----

Problem with dependency injection container:
- Currently have no methods to add a registration file that registers configuration for classes with root namespace/PHP built in classes.
- What about de-coupling the file's location with the classes' namespace? Make the autoloader better with a bootstrap, separated by namespaces too for lazy loading? Perhaps create an autoloader class so that user can specify specific class file for a specific class.
- Lazy loading seems a bit complex for users, for many projects, monolithic DIC configuration file is better? Maybe add an option to separate them into files, but make them less obvious (not the default), you need to design for this.
- Also, consider using classes as configuration files for DIC, create an interface/abstract class, and use that for configuration, easier to unit test?
- Not to forget, since we are considering using classes for DIC configurations (make them sort of pseudo factory class), what about using classes for routes too? We can have the routes implement an interface/abstract class, have them generated by the DIC and have them process the routes? Since routes are defined as groups in class, you can make it faster to discard an entire route group by just one check, no need to brute forcing it one by one (you can do this with lambda functions too, but it's much more pain to do), with the added bonus that now you can unit test your routes.

class RouteGroup
{
    public function __construct(array $routes)
    {
        $this->routes = $routes;
    }
    
    public function doRouting()
    {
        foreach ($this->routes as $route)
        {
            $destination = $route
        }
    }
}

class Route implements RouteInterface
{
    public function route()
    {
        return Destination;
    }
}

There are three core things that the library must do:
-----------------------------------------------------

- Autoload the classes, this includes a default PSR-0 way and user customized functions.
- Having a routing mechanism that the user can easily use (RouterGroup class?).
- Dependency injection container that reads user configuration and instantiates whole object graph for the user.

These three things are interconnected, and I'm having second thoughts on utilizing anonymous functions heavily for Routing and DIC.
They allow flexibility for sure, but you cannot unit test them. You can, however, unit test a class.

Example of using the new Router API:
------------------------------------

Router classes are instantiated using the DIC.

class MainRouter extends AbstractRouterGroup
{
    public function __construct()
    {
        
    }
    
    public function translate()
    {
        
    }
}

Example dependency injection container new API:
-----------------------------------------------

What about event system?

Register class instantiations to factories, but factories are also instantiated by DIC,
so if factories have dependencies it will also sort itself out. The problem is, if you
have a factory group, which factory do you call? Don't call it factory.

Register DIC ID to a class variable (do this at bootstrap?)

class Bootstrap
{
    public function registerDependencyConfigurations($dic)
    {
        $dic->register('\Vendor\ClassName@config_name', '\App\Configurations\Main->anonymousFunctionName');
        $dic->register('\Vendor\ClassName@config_name', '\App\Configurations\Main->anonymousFunctionName');
        $dic->register('\Vendor\ClassName@config_name', '\App\Configurations\Main->anonymousFunctionName');
    }
}

or use a file?

$dic->register('\Vendor\ClassName@config_name', '\Configurations\Blah->anonymousFunctionName');



The factory must be a leaf object, it acts as the container to the not so anonymous
function? Or should you create different container classes, each with their own set
of anonymous functions?

class AppConfiguration
{
    public $config_name = function($dic)
    {
        
    };
}

class AppConfiguration extends DependencyInjectionConfiguration
{   
    public function startRegistration()
    {
        $this->register('', function($dic)
        {
            return new  
        });
    }
    
    public function getInstance($instanceName, $dic)
    {
        return 
    }
}


Example autoloader class usage:
-------------------------------

$autoloader->register('\Vendor\ClassName', 'FilePath');
$autoloader->register('\Vendor\ClassName', 'AnotherFilePath');

-- DONE -- 

