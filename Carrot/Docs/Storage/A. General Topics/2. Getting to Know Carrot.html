<h1>Getting to Know Carrot</h1>

<p>
    Before you start, there are couple of things you should know
    about Carrot. This page does not explain <em>how</em> to use
    Carrot, but it will tell you things about this framework that
    would sort of introduce you to it. Reading this page is
    important because it will give you enough information to
    decide whether or not you wanted to know more about Carrot.
</p>

<h2>Carrot is an Experimental Framework</h2>

<p>
    The very first thing you need to know is that Carrot is an
    experimental framework built by someone who is in junior
    level programming level, so don't expect too much from it.
    It's not something cooked by some superstar coder. The author
    develops Carrot for his personal usage, so you might disagree
    with some of the design decisions. Since Carrot is still in
    its early stages, the author does not recommend you to use it
    in production, unless you are willing to dig deep and learn
    its core classes.
</p>

<h2>Carrot Uses Namespace and Follows PSR-0 by Default</h2>

<p>
    <a href="http://groups.google.com/group/php-standards/web/psr-0-final-proposal?pli=1">
    PSR-0 proposal</a> is an effort to standardize autoloading
    behavior of PHP classes, and Carrot adheres to this proposal
    in its <code>Carrot\Core\Autoloader</code> class. However you
    can also bind class names to specific file paths with the
    autoloader, so you should be able to use Carrot without
    following the specification.
</p>

<h2>Carrot is not a MVC Framework</h2>

<p>
// ---------------------------------------------------------------
    Carrot is a micro-framework. It doesn't offer much other than
    a dependency injection container, request, response,
    autoloader, router and 
</p>

<h2>Carrot Doesn't Use Globals and Statics</h2>

<blockquote>
    <p>
        &ldquo;The keyword static now enables us to use methods
        and properties (state) per-class and not on a per-object
        basis. This basically leaves us with class oriented
        programming. This seems to make a lot of things simpler,
        at a first glance, but will almost certainly hurt you in
        the long term.&rdquo; - <cite>
        <a href="http://kore-nordmann.de/blog/0103_static_considered_harmful.html">
        Static Considered Harmful, Kore Nordmann</a></cite>
    </p>
</blockquote>

<p>
    Carrot doesn't use globals and statics. This is a design
    decision already made and it is not going to change. In fact,
    all the code in Carrot is written so that when it is used,
    the user will never have to resort to using globals,
    constants, and statics.
</p>

<p>
    Why is globals and statics such a bad thing that Carrot
    avoided it? Here is a list, gathered from many sources:
</p>

<ul>
    <li>
        <strong>Makes your code hard to understand.</strong>
        Your code will be easier to understand if it were to use
        variables with limited scope. Global variables can be
        read or modified by any part of the program, making it
        difficult to remember or reason about every possible use.
        See also: <em>encourages tight coupling</em>.
        <a href="#source-c2"><sup>[1]</sup></a>
    </li>
    <li>
        <strong>Masks dependencies.</strong> You never know real
        dependencies of a class from its public API. You have to
        read the source code line-by-line to figure out the
        dependencies. Using statics and globals turns your code
        into pathological liars. You thought <code>Foo</code>
        doesn't know anything about <code>Bar</code> when in fact
        it uses <code>Bar</code> via a global or static keyword.
        <a href="#source-c2"><sup>[1]</sup></a>
        <a href="#source-misko-singleton-liars">
        <sup>[2]</sup></a>
    </li>
    <li>
        <strong>Breaks encapsulation.</strong> In OOP, data and
        behavior should be encapsulated in one object. If the
        object somehow reaches out of its boundaries to the
        global state, you are breaking encapsulation.
        <a href="#source-so-gordon-globals"><sup>[3]</sup></a>
    </li>
    <li>
        <strong>Encourages tight coupling.</strong> In an ideal
        world, an object should only be able to interact only
        with other objects which are directly passed into it,
        either through a constructor or method call. With the
        existence of globals and statics, object <code>Foo</code>
        can get a hold of globally accessible <code>Bar</code>
        even though it is not supposed to have access to it. This
        couples <code>Foo</code> with the global state, and if
        there is a bug related to <code>Bar</code>, you'll have
        to hunt the entire source code because you don't know
        which part of the code actually uses it.
        <a href="#source-misko-globals-flaw"><sup>[4]</sup></a>
    </li>
    <li>
        <strong>Spooky action at a distance.</strong> Whenever
        you use globals or statics, you are creating secret
        communications channel that are not exposed in the API.
        This allows <a href="http://en.wikipedia.org/wiki/Action_at_a_distance_%28computer_science%29">
        spooky action at a distance</a> to happen. It's when you
        run a method that is supposed to be isolated, but an
        action occurs in distant locations of the system which
        you did not tell the object about. When this happens,
        it forces developers to read every line of code to
        understand potential interactions. See also:
        <em>makes your code hard to understand</em>.
        <a href="#source-misko-globals-flaw"><sup>[4]</sup></a>
    </li>
    <li>
        <strong>Creates static dependencies.</strong> When you're
        using static methods, you are creating a static
        dependency that you might not be able to replace by any
        means other than editing the source. Let's say
        <code>Foo</code> has a static dependency to
        <code>Bar::baz()</code>, and you need to switch
        <code>Baz</code> implementation to <code>Bar</code>. You
        won't be able to do that without editing
        <code>Foo</code>'s source. In OOP with dependency
        injection, you should be able to do this simply by
        injecting another class, adhering to
        <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle">
        Liskov's subtitution principle</a>.
        <a href="#source-kore-static-harmful"><sup>[5]</sup></a>
    </li>
    <li>
        <strong>Makes unit testing very difficult.</strong> Unit
        testing needs seams. It's where the execution of normal
        code is prevented and the class being tested is isolated.
        Without isolation, there is no unit test. Usually to do
        this, polymorphism and dependency injection is utilized.
        An interface is overridden/implemented and injected to
        the class. This is not possible to do with statics. The
        usage of global state also means that every test must
        start in an expected state, or the test will fail.
        <a href="#source-misko-globals-flaw"><sup>[4]</sup></a>
        <a href="#source-misko-statics-testability">
        <sup>[6]</sup></a>
    </li>
</ul>

<p>
    I'm sure there are more reasons why globals and statics
    should be avoided, but let's just leave it at that. Please
    note that there are lots of positions regarding globals and
    statics. There are camps that stay away from globals but is
    okay with statics since it doesn't pollute the global
    namespace. But this is a very slippery slope that I decided
    not to use it altogether. You can think of Carrot as an
    ongoing experiment on whether we can write a fully functional
    PHP framework without the usage of globals and statics.
</p>

<p>
    Ruling out globals and statics means also ruling out
    <a href="http://martinfowler.com/eaaCatalog/registry.html">
    Registry</a> and <a href="http://en.wikipedia.org/wiki/Singleton_pattern">
    Singleton pattern</a>. This perplexes me for a while, since
    Carrot as a framework must provide a way for user's classes
    to access other instantiated objects. I need a way to wire
    the dependencies without resorting to globals or inheritance.
    I found the solution in <a href="http://martinfowler.com/articles/injection.html">
    dependency injection container</a> - hence why the usage of
    dependency injection container is mandatory in Carrot. More
    on this later.
</p>

<h3>Sources</h3>
<ol>
    <li id="source-c2"><cite><a href="http://c2.com/cgi/wiki?GlobalVariablesAreBad">Global Variables are Bad</a>.</cite></li>
    <li id="source-misko-singleton-liars"><cite><a href="http://misko.hevery.com/2008/08/17/singletons-are-pathological-liars/">Singletons are Pathological Liars</a>, Misko Hevery.</cite></li>
    <li id="source-so-gordon-globals"><cite><a href="http://stackoverflow.com/questions/5166087/php-global-in-functions/5166527#5166527">Globals are Evil</a>, Gordon Oheim.</cite></li>
    <li id="source-misko-globals-flaw"><cite><a href="http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/">Flaw: Brittle Global State and Singletons</a>, Misko Hevery.</cite></li>
    <li id="source-kore-static-harmful"><cite><a href="http://kore-nordmann.de/blog/0103_static_considered_harmful.html">Static Considered Harmful</a>, Kore Nordmann.</cite></li>
    <li id="source-misko-statics-testability"><cite><a href="http://googletesting.blogspot.com/2008/12/static-methods-are-death-to-testability.html">Static Methods are Death to Testability</a>, Misko Hevery.</cite></li>
</ol>

<h2>
    Carrot Requires You to Use its Dependency Injection Container
</h2>

<p>
    You will not be able to use Carrot without
    <code>Carrot\Core\DependencyInjectionContainer</code>
    instance. Carrot relies on the container to inject
    dependencies to your classes and some of its core classes.
    Just like any other tool, there are drawbacks and benefits of
    using a DIC. Naturally, as I'm using it, I think the benefits
    far outweigh the potential disadvantage. I understand this is
    not a view shared by everyone, which is why I am telling you
    beforehand. However, please read on so that you
    
    I am also going to introduce you to the
    relationship between your classes and the container.
</p>

<p>
    The classes you write does not know and/or aware of being
    managed by the dependency injection container. Your dependency
    configuration and behavior are separated. You define an
    instance name for your instantiation configuration and bind
    constructor arguments to it at <code>config.php</code>, like
    this:
</p>

<pre>$dic->bind('MySQLi{MainDatabase:Singleton}', array(
    'hostname',
    'username',
    'password',
    'database'
));
</pre>

<p>
    The instance name also works as an object reference. So if
    your class has a dependency to the above instance of
    <code>MySQLi</code>, use the instance name as a reference when
    binding constructor arguments:
</p>

<pre>$dic->bind('YourClass{Main:Transient}', array(
    new ObjectReference('MySQLi{MainDatabase:Singleton}')
));
</pre>

<p>
    Courtesy of the container, when you write your class, you no
    longer have to worry about how to get your dependencies. Your
    class can also be a plain old PHP object. Just use regular
    constructor injection, as such:
</p>

<pre>class YourClass
{
    private $mysqli;
    
    public function __construct(MySQLi $mysqli)
    {
        $this->mysqli = $mysqli;
    }
}
</pre>

<p>
    If you need to have logic in your class construction or wanted
    to use setter injection, you can write a provider class and
    bind it using the container. Aspects of the relationship
    between the classes you wrote in Carrot and its dependency
    injection container are summarized in this list:
</p>

<ul>
    <li>
        The container instantiates your class for Carrot.
    </li>
    <li>
        The container injects your classes' dependencies using
        constructor injection, provided they were configured
        directly.
    </li>
    <li>
        Your class doesn't have references to the container
        instance (and it shouldn't).
    </li>
    <li>
        You can instantiate the class you wrote without going
        through Carrot's container.
    </li>
    <li>
        You don't have to extend any base class to use the
        container. Carrot doesn't have base classes.
    </li>
</ul>

<p>
    More information about Carrot's dependency injection container
    implementation can be read at the dependency injection
    container guide page.
</p>