<h1>Why No Globals and statics</h1>

<blockquote>
    <p>
        &ldquo;The keyword static now enables us to use methods
        and properties (state) per-class and not on a per-object
        basis. This basically leaves us with class oriented
        programming. This seems to make a lot of things simpler,
        at a first glance, but will almost certainly hurt you in
        the long term.&rdquo; - <cite>
        <a href="http://kore-nordmann.de/blog/0103_static_considered_harmful.html">
        Static Considered Harmful, Kore Nordmann</a></cite>
    </p>
</blockquote>

<p>
    Carrot doesn't use globals and statics. This is a design
    decision already made and it is not going to change. In fact,
    all the code in Carrot is written so that when it is used,
    the user will never have to resort to using globals, constants,
    and statics. Why is globals and statics such a bad thing that
    I wanted to avoid it? Here is a list, gathered from many
    sources:
</p>

<ul>
    <li>
        <strong>Makes your code hard to understand.</strong>
        Your code will be easier to understand if it were to use
        variables with limited scope. Global variables can be read
        or modified by any part of the program, making it difficult
        to remember or reason about every possible use. See also:
        <em>encourages tight coupling</em>. <a href="#source-c2">
        <sup>[1]</sup></a>
    </li>
    <li>
        <strong>Masks dependencies.</strong> You never know real
        dependencies of a class from its public API. You have to
        read the source code line-by-line to figure out the
        dependencies. Using statics and globals turns your code
        into pathological liars. You thought <code>Foo</code> doesn't
        know anything about <code>Bar</code> when in fact it uses
        <code>Bar</code> via a global or static keyword.
        <a href="#source-c2"><sup>[1]</sup></a>
        <a href="#source-misko-singleton-liars"><sup>[2]</sup></a>
    </li>
    <li>
        <strong>Breaks encapsulation.</strong> In OOP, data and
        behavior should be encapsulated in one object. If the
        object somehow reaches out of its boundaries to the
        global state, you are breaking encapsulation.
        <a href="#source-so-gordon-globals"><sup>[3]</sup></a>
    </li>
    <li>
        <strong>Encourages tight coupling.</strong> In an ideal
        world, an object should only be able to interact only
        with other objects which are directly passed into it,
        either through a constructor or method call. With the
        existence of globals and statics, object <code>Foo</code>
        can get a hold of globally accessible <code>Bar</code>
        even though it is not supposed to have access to it.
        This couples <code>Foo</code> with the global state,
        and if there is a bug related to <code>Bar</code>,
        you'll have to hunt the entire source code because you
        don't know which part of the code actually uses it.
        <a href="#source-misko-globals-flaw"><sup>[4]</sup></a>
    </li>
    <li>
        <strong>Spooky action at a distance.</strong> Whenever
        you use globals or statics, you are creating secret
        communications channel that are not exposed in the API.
        This allows <a href="http://en.wikipedia.org/wiki/Action_at_a_distance_%28computer_science%29">
        spooky action at a distance</a> to happen. It's when you
        run a method that is supposed to be isolated, but an
        action occurs in distant locations of the system which
        you did not tell the object about. When this happens,
        it forces developers to read every line of code to understand
        potential interactions. See also:
        <em>makes your code hard to understand</em>.
        <a href="#source-misko-globals-flaw"><sup>[4]</sup></a>
    </li>
    <li>
        <strong>Creates static dependencies.</strong> When you're
        using static methods, you are creating a static dependency
        that you might not be able to replace by any means other
        than editing the source. Let's say <code>Foo</code> has a
        static dependency to <code>Bar::baz()</code>, and you need
        to change the implementation of <code>Baz</code>. You won't
        be able to do that without editing <code>Foo</code>'s source.
        In OOP with dependency injection, you should be able to do
        this simply by injecting another class, adhering to
        <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle">
        Liskov's subtitution principle</a>.
        <a href="#source-kore-static-harmful"><sup>[5]</sup></a>
    </li>
    <li>
        <strong>Makes unit testing very difficult.</strong> Unit
        testing needs seams. It's where the execution of normal code
        is prevented and the class being tested is isolated. Without
        isolation, there is no unit test. Usually to do this,
        polymorphism and dependency injection is utilized. An
        interface is overridden/implemented and injected to the class.
        This is not possible to do with statics. The usage of
        global state also means that every test must start in an
        expected state, or the test will fail.
        <a href="#source-misko-globals-flaw"><sup>[4]</sup></a>
        <a href="#source-misko-statics-testability"><sup>[6]</sup>
        </a>
    </li>
</ul>

<p>
    I'm sure there are more reasons why globals and statics should
    be avoided, but let's just leave it at that. Please note that
    there are lots of positions regarding globals and statics.
    There are camps that stay away from globals but is okay with
    statics since it doesn't pollute the global namespace. But this
    is a very slippery slope that I decided not to use it altogether.
    You can think of Carrot as an ongoing experiment on whether we
    can write a fully functional PHP framework without the usage
    of globals and statics.
</p>

<p>
    Ruling out globals and statics means also ruling out
    <a href="http://martinfowler.com/eaaCatalog/registry.html">
    Registry</a> and <a href="http://en.wikipedia.org/wiki/Singleton_pattern">
    Singleton pattern</a>. This perplexes me for a while, since Carrot
    as a framework must provide a way for user's classes to access other
    instantiated objects. I need a way to wire the dependencies without
    resorting to globals or inheritance. I found the solution in
    <a href="http://martinfowler.com/articles/injection.html">
    dependency injection container</a> - hence why the usage of dependency
    injection container is mandatory in Carrot. More on this later.
</p>

<h3>Sources</h3>
<ol>
    <li id="source-c2"><cite><a href="http://c2.com/cgi/wiki?GlobalVariablesAreBad">Global Variables are Bad</a>.</cite></li>
    <li id="source-misko-singleton-liars"><cite><a href="http://misko.hevery.com/2008/08/17/singletons-are-pathological-liars/">Singletons are Pathological Liars</a>, Misko Hevery.</cite></li>
    <li id="source-so-gordon-globals"><cite><a href="http://stackoverflow.com/questions/5166087/php-global-in-functions/5166527#5166527">Globals are Evil</a>, Gordon Oheim.</cite></li>
    <li id="source-misko-globals-flaw"><cite><a href="http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/">Flaw: Brittle Global State and Singletons</a>, Misko Hevery.</cite></li>
    <li id="source-kore-static-harmful"><cite><a href="http://kore-nordmann.de/blog/0103_static_considered_harmful.html">Static Considered Harmful</a>, Kore Nordmann.</cite></li>
    <li id="source-misko-statics-testability"><cite><a href="http://googletesting.blogspot.com/2008/12/static-methods-are-death-to-testability.html">Static Methods are Death to Testability</a>, Misko Hevery.</cite></li>
</ol>