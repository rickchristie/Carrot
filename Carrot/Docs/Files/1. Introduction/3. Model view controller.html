<h1>Carrot is not an MVC or MV-whats-its-name framework</h1>

<p>
    Carrot is as a micro-framework. It does not make assumption
    on how you separate the layers in your application. It just
    knows one thing, that it needs to set up the environment,
    call your class to get the response, and that's it. It does
    not care, much less dictate how you're doing it. 
</p>

<h2>Layering your application in Carrot</h2>

<p>
    Since all of your classes are plain old PHP classes, you
    should have complete freedom in layering your application.
    Carrot does not dictate how you create your views,
    controllers, or models. You can probably built your
    MVC implementation on top of Carrot, but you
    don't have to tell Carrot about it, and it certainly does not
    need to know.
</p>

<h2>&lsquo;Actions&rsquo; in Carrot</h2>

<p>
    Usually, in a PHP framework, developers will first be guided
    in building their controller, <code>BlogController</code>
    as an example. The developer will then create an
    &lsquo;action&rsquo; method on that framework, like
    <code>BlogController::showPost()</code>. The next
    step is then to create a route that points to that
    action the developer has just created.
</p>

<p>
    Since Carrot is not an MVC framework, it does not subscribe
    to any MV-whats-its-name implementation. Therefore, the
    routes can return a <code>Destination</code> instance that
    points to any class you want. It can be your view class,
    your controller, or anything. Carrot does not care. What it
    does care about, is whether the method it calls returns an
    instance of <code>ResponseInterface</code> or not.
</p>